from dataclasses import dataclass
from typing import Any, Dict, List, Iterator, Generator

import networkx

from redag.entity.redag_annotations_processor import RedagAnnotationsProcessor as RAP
from redag.entity.redag_types import Entity, EntityValue
from redag.relation_graph import RelationGraph
from redag.utils import Singleton


class REDAG(metaclass=Singleton):
    @dataclass
    class Sample:
        # Value is a list of all objects of type @key generated by REDAG for the sample.
        entities: Dict[Entity, List[EntityValue]]

        def merge(self, s: 'REDAG.Sample') -> 'REDAG.Sample':
            for t, l in s.entities.items():
                self.entities.setdefault(t, []).extend(l)
            return self

    def __init__(self):
        self.__entities = []
        self.__relation_graph = RelationGraph()

    def generate(self) -> 'Generator[REDAG.Sample, REDAG.Sample, None]':
        self.__relation_graph.link_nodes()
        while True:
            yield self.__sample(self.__relation_graph.topological_sort(), {})

    def register_entity(self, cls: Entity) -> None:
        self.__entities.append(cls)
        self.__relation_graph.add_node(cls)

    def __validate_relation_graph(self) -> None:
        if not networkx.is_directed_acyclic_graph(self.__relation_graph):
            raise ValueError("Relation graph contains cycles!")

    def __sample(self, nodes_to_generate: Iterator[Entity], parents: Dict[Entity, Any]) -> Sample:
        result = REDAG.Sample(entities={})

        try:
            node = next(nodes_to_generate)
        except StopIteration:
            return result
        # How many entities of type @node should we generate
        multiplicity = RAP.get_entity_multiplicity_generator(node).__get__(None, node)(parents=parents)
        sampling_state = {"multiplicity": multiplicity}
        for i in range(0, multiplicity):
            value = RAP.get_entity_generator(node).__get__(None, node)(parents=parents, state=sampling_state)
            parents[node] = value
            # Recursively generate any entities which reference @node
            result.merge(self.__sample(nodes_to_generate, parents)).merge(REDAG.Sample(entities={node: [value]}))
        return result
